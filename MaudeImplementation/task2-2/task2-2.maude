
fmod 2-TUPLE is
  pr NAT .
  sort 2-Tuple .
  op <_;_> : Nat Nat -> 2-Tuple .
  
endfm

view 2-Tuple from TRIV to 2-TUPLE is  
    sort Elt to 2-Tuple .  
endv

fmod MAYBE{X :: TRIV} is
  sort Maybe{X} .
  subsort X$Elt < Maybe{X} .
  op null : -> Maybe{X} .
endfm

view Object from TRIV to CONFIGURATION is
  sort Elt to Object .
endv

mod TASK2-2 is
  pr TASK1 .
  ex SET{2-Tuple} .
  pr MAYBE{Object} .
  ex SET{Nat} .
  
  **************************************************
  **** Auxiliar functions
  **************************************************
  var T : 2-Tuple .
  op isEmpty? : Set{2-Tuple} -> Bool .
  eq isEmpty?(empty) = true .
  eq isEmpty?((T, TS)) = false .
  
  
  op findCouples : -> Msg [ctor] .
  
  op {_}{_}{_}{_}{_}{_} : Configuration Configuration Configuration Configuration Maybe{Object} Set{2-Tuple} -> Set{2-Tuple} .
  ---- starting argument
  ---- persons
  ---- movies 
  ---- persons dealt
  ---- fixed person on which we iterate
  ---- set of pairs as result
  op {_} : Configuration -> Set{2-Tuple} .
  
  op areCouple? : Object Object -> Bool .
  op couple : Object Object -> 2-Tuple .
  
  ************
  **** Vars
  ************
  var Conf C1 C2 C3 C4 : Configuration .
  vars O O1 O2 O3 : Nat .
  vars Atts Atts1 Atts2 Atts3 : AttributeSet .
  var V@Person : Person .
  var MS1 MS2 : Set{Nat} .
  var TS TS1 TS2 : Set{2-Tuple} .
  var Ob1 Ob2 : Object .
  
  rl [create5Tuple] :
    { findCouples Conf }
  =>
    { Conf }{ none }{ none }{ none }{ null }{ empty } .
    
    
  ---------------------------------------------------------------------------------
  ---- 1st step: We split Persons and Movies into their configurations
  --------------------------------------------------------------------------------- 
    
  rl [splitPersons] :
    { < O : V@Person | Atts >  Conf }
    { C2 }{ C3 }{ none }{ null }{ empty }
  => 
    { Conf }{ < O : V@Person | Atts >  C2 }
    { C3 }{ none }{ null }{ empty } .
  
  rl [splitMovies] :
    { < O : Movie | Atts >  Conf }
    { C2 }{ C3 }{ none }{ null }{ empty }
  => 
    { Conf }{ C2 }
    { < O : Movie | Atts > C3 }{ none }{ null }{ empty } .
  
  rl [splitMessages] :
    { M:Msg Conf }
    { C2 }{ C3 }{ none }{ null }{ empty }
  => 
    { Conf }{ C2 }{ C3 }{ none }{ null }{ empty } .
    
  ---------------------------------------------------------------------------------
  ---- 2nd step: We fix an actor or actress
  ---------------------------------------------------------------------------------
  
  rl [fixingPerson] : 
    { none }{ < O : V@Person | Atts > C1 }{ C2 }{ none }{ null }{ TS } 
  => 
    { none }{ C1 }{ C2 }{ none }{ < O : V@Person | Atts > }{ TS } .

  ---------------------------------------------------------------------------------
  ---- 3rd step: Look for all pairs given a person
  --------------------------------------------------------------------------------- 
  
  rl [doingPairs] :
    { none }{ < O1 : V@Person | movies : MS1, Atts1 >  C1 }{ C2 }{ C3 }
    { < O2 : V@Person | movies : MS2, Atts2 > }{ TS } 
  => 
    if | intersection(MS1, MS2) | > 0
    then { none }{ C1 }{ C2 }{ < O1 : V@Person | movies : MS1, Atts1 > C3 }{ < O2 : V@Person | movies : MS2, Atts2 > }
         { (< O1 ; O2 >, TS) }
    else { none }{ C1 }{ C2 }{ < O1 : V@Person | movies : MS1, Atts1 > C3 }{ < O2 : V@Person | movies : MS2, Atts2 > }
         { TS }
    fi .
    
  eq couple(< O1 : V@Person | Atts1 >, < O2 : V@Person | Atts2 >) = < O1 ; O2 > .
  
***(   eq searchMovies(< O1 : Movie | Atts1 > Conf, 
                  < O2 : V@Person | movies : (MS1), Atts2 >, 
                  < O3 : V@Person | movies : (MS2), Atts3 >)
      = if ((O1 in MS1) and (O1 in MS2))
        then (< O2 ; O3 >, searchMovies(Conf, < O2 : V@Person | movies : (O1, MS1), Atts2 >, 
                                              < O3 : V@Person | movies : (O1, MS2), Atts3 >))
        else (searchMovies(Conf, < O2 : V@Person | movies : (O1, MS1), Atts2 >, 
                                 < O3 : V@Person | movies : (O1, MS2), Atts3 >))
        fi .
 eq searchMovies(none, Ob1, Ob2) = empty .
)
 ---------------------------------------------------------------------------------
 ---- 4th step: If the current Person set has been gone over all the other persons
 ----           we set the next person
 --------------------------------------------------------------------------------- 
 rl [setNextPerson] : 
   { none } { none } { C2 } { C3 } { < O2 : V@Person | Atts1 > } { TS } 
 => 
   { none } { C3 } { C2 } { none } { null } { TS }  .
 
 ---------------------------------------------------------------------------------
 ---- 4th step:
 ---------------------------------------------------------------------------------
 rl { none } { none } { C2 } { none } { null } { TS }  => TS  .
  
endm

red in TASK2-2 : intersection((1, 2, 3), (2, 3, 4)) .

match < O1 : V@Person | movies : MS1, Atts1 > <=? 
  < 6 : Actor | name : "a1",
    movies : (0, 1, 2) > .
    
    rew in TASK2-2 : { findCouples freshOid(20) < 6 : Actor | name : "a1",
        movies : (0, 1, 2) > < 7 : Actor | name : "a2",movies : (1, 2, 3) > } .

rew in TASK2-2 : | { findCouples freshOid(20) < 0 : Movie | rating : 0.0 > < 1 : Movie | rating :
    1.0 > < 2 : Movie | rating : 2.0 > < 3 : Movie | rating : 3.0 > < 4 : Movie | rating
    : 4.0 > < 5 : Actor | name : "a0",movies : (0, 1, 2, 3) > < 6 : Actor | name : "a1",
    movies : (0, 1, 2) > < 7 : Actor | name : "a2",movies : (1, 2, 3) > < 8 : Actor |
    name : "a3",movies : (1, 2, 3, 4) > < 9 : Actor | name : "a4",movies : (1, 2, 3, 4) >
    < 10 : Movie | rating : 5.0 > < 11 : Movie | rating : 6.0 > < 12 : Movie | rating :
    7.0 > < 13 : Movie | rating : 8.0 > < 14 : Movie | rating : 9.0 > < 15 : Actor | name
    : "a5",movies : (10, 11) > < 16 : Actor | name : "a6",movies : (10, 11, 12) > < 17 :
    Actor | name : "a7",movies : (11, 12, 13) > < 18 : Actor | name : "a8",movies : (12,
    13, 14) > < 19 : Actor | name : "a9",movies : (13, 14) > } | .