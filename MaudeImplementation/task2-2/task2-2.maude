
fmod 2-TUPLE is
  pr NAT .
  sort 2-Tuple .
  op <_;_> : Nat Nat -> 2-Tuple .
  
endfm

view 2-Tuple from TRIV to 2-TUPLE is  
    sort Elt to 2-Tuple .  
endv

fmod MAYBE{X :: TRIV} is
  sort Maybe{X} .
  subsort X$Elt < Maybe{X} .
  op null : -> Maybe{X} .
endfm

view Object from TRIV to CONFIGURATION is
  sort Elt to Object .
endv

mod TASK2-2 is
  pr TASK1 .
  ex SET{2-Tuple} .
  pr MAYBE{Object} .
  
  **************************************************
  **** Auxiliar functions
  **************************************************
  var T : 2-Tuple .
  op isEmpty? : Set{2-Tuple} -> Bool .
  eq isEmpty?(empty) = true .
  eq isEmpty?((T, TS)) = false .
  
  
  op findCouples : -> Msg [ctor] .
  
  op {_}{_}{_}{_}{_}{_} : Configuration Configuration Configuration Configuration Maybe{Object} Set{2-Tuple} -> Set{2-Tuple} .
  ---- starting argument
  ---- persons
  ---- movies 
  ---- persons dealt
  ---- fixed person on which we iterate
  ---- set of pairs as result
  op {_} : Configuration -> Set{2-Tuple} .
  
  op searchMovies : Configuration Object Object -> Set{2-Tuple} .
  
  ************
  **** Vars
  ************
  var Conf C1 C2 C3 C4 : Configuration .
  vars O O1 O2 O3 : Nat .
  vars Atts Atts1 Atts2 Atts3 : AttributeSet .
  var V@Person : Person .
  var MS1 MS2 : Set{Nat} .
  var TS TS1 TS2 : Set{2-Tuple} .
  var Ob1 Ob2 : Object .
  
  rl [create5Tuple] :
    { findCouples Conf }
  =>
    { Conf }{ none }{ none }{ none }{ null }{ empty } .
    
    
  ---------------------------------------------------------------------------------
  ---- 1st step: We split Persons and Movies into their configurations
  --------------------------------------------------------------------------------- 
    
  rl [splitPersons] :
    { < O : V@Person | Atts >  Conf }
    { C2 }{ C3 }{ none }{ null }{ empty }
  => 
    { Conf }{ < O : V@Person | Atts >  C2 }
    { C3 }{ none }{ null }{ empty } .
  
  rl [splitMovies] :
    { < O : Movie | Atts >  Conf }
    { C2 }{ C3 }{ none }{ null }{ empty }
  => 
    { Conf }{ C2 }
    { < O : Movie | Atts > C3 }{ none }{ null }{ empty } .
  
  rl [splitMessages] :
    { M:Msg Conf }
    { C2 }{ C3 }{ none }{ null }{ empty }
  => 
    { Conf }{ C2 }{ C3 }{ none }{ null }{ empty } .
    
  ---------------------------------------------------------------------------------
  ---- 2nd step: We fix an actor or actress
  ---------------------------------------------------------------------------------
  
  rl [fixingPerson] : 
    { none }{ < O : V@Person | Atts > C1 }{ C2 }{ none }{ null }{ TS } 
  => 
    { none }{ C1 }{ C2 }{ none }{ < O : V@Person | Atts > }{ TS } .

  ---------------------------------------------------------------------------------
  ---- 3rd step: Look for all pairs given a person
  --------------------------------------------------------------------------------- 
  
  rl [doingPairs] :
    { none }{ < O1 : V@Person | Atts1 >  C1 }{ C2 }{ C3 }{ < O2 : V@Person | Atts2 > }{ TS } 
  => 
    if not(isEmpty?(searchMovies(C2, < O1 : V@Person | Atts1 >, < O2 : V@Person | Atts2 >)))
    then { none }{ C1 }{ C2 }{ < O1 : V@Person | Atts1 > C3 }{ < O2 : V@Person | Atts2 > }
         { (searchMovies(C2, < O1 : V@Person | Atts1 >, < O2 : V@Person | Atts2 >), TS) }
    else { none }{ C1 }{ C2 }{ C3 }{ < O2 : V@Person | Atts2 > }{ TS }
    fi .
  
  eq searchMovies(< O1 : Movie | Atts1 > Conf, 
                  < O2 : V@Person | movies : (MS1), Atts2 >, 
                  < O3 : V@Person | movies : (MS2), Atts3 >)
      = if ((O1 in MS1) and (O1 in MS2))
        then (< O2 ; O3 >, searchMovies(Conf, < O2 : V@Person | movies : (O1, MS1), Atts2 >, 
                                              < O3 : V@Person | movies : (O1, MS2), Atts3 >))
        else (searchMovies(Conf, < O2 : V@Person | movies : (O1, MS1), Atts2 >, 
                                 < O3 : V@Person | movies : (O1, MS2), Atts3 >))
        fi .
 eq searchMovies(none, Ob1, Ob2) = empty .
 
 ---------------------------------------------------------------------------------
 ---- 4th step: If the current Person set has been gone over we set the next person
 --------------------------------------------------------------------------------- 
 rl [setNextPerson] : 
   { none } { none } { C2 } { C3 } { < O2 : V@Person | Atts1 > } { TS } 
 => 
   { none } { C3 } { C2 } { none } { null } { TS }  .
 
 ---------------------------------------------------------------------------------
 ---- 4th step:
 ---------------------------------------------------------------------------------
 rl { none } { none } { C2 } { none } { null } { TS }  => TS  .
  
endm